import{_ as e,c as t,a0 as s,j as i,e as h,o as n}from"./chunks/framework.V6wbqQ68.js";const g=JSON.parse('{"title":"第 4 章 变量、作用域与内存","description":"","frontmatter":{"outline":[2,4]},"headers":[],"relativePath":"website/language/JavaScript/High-Performance JavaScript/第4章 变量、作用域与内存.md","filePath":"website/language/JavaScript/High-Performance JavaScript/第4章 变量、作用域与内存.md"}'),l={name:"website/language/JavaScript/High-Performance JavaScript/第4章 变量、作用域与内存.md"};function r(p,a,k,d,o,c){return n(),t("div",null,[a[1]||(a[1]=s(`<h1 id="第-4-章-变量、作用域与内存" tabindex="-1">第 4 章 变量、作用域与内存 <a class="header-anchor" href="#第-4-章-变量、作用域与内存" aria-label="Permalink to &quot;第 4 章 变量、作用域与内存&quot;">​</a></h1><h2 id="_4-1-原始值与引用值" tabindex="-1">4.1 原始值与引用值 <a class="header-anchor" href="#_4-1-原始值与引用值" aria-label="Permalink to &quot;4.1 原始值与引用值&quot;">​</a></h2><p>JavaScript 不允许直接访问内存位置。</p><p>原始值大小固定，因此保存在栈内存上。引用值是对象，存储在堆内存上。</p><p>包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。</p><p>从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。</p><details class="details custom-block"><summary>原始值和引用值的终极面试题</summary><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { bar: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, foo]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr2[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr2[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo.bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr1[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr1[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr2[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr1[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr2[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo.bar)</span></span></code></pre></div></details><h4 id="_4-1-1-动态属性" tabindex="-1">4.1.1 动态属性 <a class="header-anchor" href="#_4-1-1-动态属性" aria-label="Permalink to &quot;4.1.1 动态属性&quot;">​</a></h4><p>给原始值添加属性不会报错</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;LBJhui&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 28</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name.age) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span></code></pre></div><h4 id="_4-1-2-复制值" tabindex="-1">4.1.2 复制值 <a class="header-anchor" href="#_4-1-2-复制值" aria-label="Permalink to &quot;4.1.2 复制值&quot;">​</a></h4><p>通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来</p><h4 id="_4-1-3-传递参数" tabindex="-1">4.1.3 传递参数 <a class="header-anchor" href="#_4-1-3-传递参数" aria-label="Permalink to &quot;4.1.3 传递参数&quot;">​</a></h4><p>ECMAScript 中所有函数的参数都是按值传递的。</p><h4 id="_4-1-4-确定类型" tabindex="-1">4.1.4 确定类型 <a class="header-anchor" href="#_4-1-4-确定类型" aria-label="Permalink to &quot;4.1.4 确定类型&quot;">​</a></h4><p>typeof 操作符最适合用来判断一个变量是否为原始类型。</p><p><code>result = variable instanceof constructor</code></p><h2 id="_4-2-执行上下文与作用域" tabindex="-1">4.2 执行上下文与作用域 <a class="header-anchor" href="#_4-2-执行上下文与作用域" aria-label="Permalink to &quot;4.2 执行上下文与作用域&quot;">​</a></h2><p>通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。</p><p>❑ 执行上下文分全局上下文、函数上下文和块级上下文。<br> ❑ 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。<br> ❑ 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。<br> ❑ 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。<br> ❑ 变量的执行上下文用于确定什么时候释放内存。</p><h3 id="_4-2-1-作用域链增强" tabindex="-1">4.2.1 作用域链增强 <a class="header-anchor" href="#_4-2-1-作用域链增强" aria-label="Permalink to &quot;4.2.1 作用域链增强&quot;">​</a></h3><p>❑ try/catch 语句的 catch 块<br> ❑ with 语句</p><p>会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。</p><h3 id="_4-2-2-变量声明" tabindex="-1">4.2.2 变量声明 <a class="header-anchor" href="#_4-2-2-变量声明" aria-label="Permalink to &quot;4.2.2 变量声明&quot;">​</a></h3><h4 id="_1-使用-var-的函数作用域声明" tabindex="-1">1．使用 var 的函数作用域声明 <a class="header-anchor" href="#_1-使用-var-的函数作用域声明" aria-label="Permalink to &quot;1．使用 var 的函数作用域声明&quot;">​</a></h4><p>变量提升</p><h4 id="_2-使用-let-的块级作用域声明" tabindex="-1">2．使用 let 的块级作用域声明 <a class="header-anchor" href="#_2-使用-let-的块级作用域声明" aria-label="Permalink to &quot;2．使用 let 的块级作用域声明&quot;">​</a></h4><p>作用域是块级的。块级作用域由最近的一对包含花括号<code>{}</code>界定。</p><p><code>let</code> 与 <code>var</code> 的另一个不同之处是在同一作用域内不能声明两次。重复的 <code>var</code> 声明会被忽略，而重复的 <code>let</code> 声明会抛出 SyntaxError。</p><p>暂时性死区 ​（temporal dead zone）</p><h4 id="_3-使用-const-的常量声明" tabindex="-1">3．使用 const 的常量声明 <a class="header-anchor" href="#_3-使用-const-的常量声明" aria-label="Permalink to &quot;3．使用 const 的常量声明&quot;">​</a></h4><p>使用 <code>const</code> 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p><p><code>const</code> 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 <code>const</code> 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p><p>如果想让整个对象都不能修改，可以使用 <code>Object.freeze()</code>，这样再给属性赋值时虽然不会报错，但会静默失败：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> o3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">freeze</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">o3.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Jake&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o3.name) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span></code></pre></div>`,35)),i("p",null,[a[0]||(a[0]=i("a",{href:"./../1.变量声明(var,let和const)"},"变量声明(var,let 和 const)",-1)),h("",!0)]),a[2]||(a[2]=s('<h4 id="_4-标识符查找" tabindex="-1">4．标识符查找 <a class="header-anchor" href="#_4-标识符查找" aria-label="Permalink to &quot;4．标识符查找&quot;">​</a></h4><h2 id="_4-3-垃圾回收" tabindex="-1">4.3 垃圾回收 <a class="header-anchor" href="#_4-3-垃圾回收" aria-label="Permalink to &quot;4.3 垃圾回收&quot;">​</a></h2><p>❑ 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。<br> ❑ 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。<br> ❑ 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象（如 DOM 元素）​。<br> ❑ 引用计数在代码中存在循环引用时会出现问题。<br> ❑ 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。</p><h3 id="_4-3-1-标记清理" tabindex="-1">4.3.1 标记清理 <a class="header-anchor" href="#_4-3-1-标记清理" aria-label="Permalink to &quot;4.3.1 标记清理&quot;">​</a></h3><h3 id="_4-3-2-引用计数" tabindex="-1">4.3.2 引用计数 <a class="header-anchor" href="#_4-3-2-引用计数" aria-label="Permalink to &quot;4.3.2 引用计数&quot;">​</a></h3><p>循环引用时无法回收内存</p><h3 id="_4-3-3-性能" tabindex="-1">4.3.3 性能 <a class="header-anchor" href="#_4-3-3-性能" aria-label="Permalink to &quot;4.3.3 性能&quot;">​</a></h3><p>在 IE 中，<code>window.CollectGarbage()</code>方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用 <code>window. opera.collect()</code>也会启动垃圾回收程序。</p><h3 id="_4-3-4-内存管理" tabindex="-1">4.3.4 内存管理 <a class="header-anchor" href="#_4-3-4-内存管理" aria-label="Permalink to &quot;4.3.4 内存管理&quot;">​</a></h3><p>及时解除引用</p><h4 id="_1-通过-const-和-let-声明提升性能" tabindex="-1">1．通过 const 和 let 声明提升性能 <a class="header-anchor" href="#_1-通过-const-和-let-声明提升性能" aria-label="Permalink to &quot;1．通过 const 和 let 声明提升性能&quot;">​</a></h4><h4 id="_2-隐藏类和删除操作" tabindex="-1">2．隐藏类和删除操作 <a class="header-anchor" href="#_2-隐藏类和删除操作" aria-label="Permalink to &quot;2．隐藏类和删除操作&quot;">​</a></h4><h4 id="_3-内存泄漏" tabindex="-1">3．内存泄漏 <a class="header-anchor" href="#_3-内存泄漏" aria-label="Permalink to &quot;3．内存泄漏&quot;">​</a></h4><h4 id="_4-静态分配与对象池" tabindex="-1">4．静态分配与对象池 <a class="header-anchor" href="#_4-静态分配与对象池" aria-label="Permalink to &quot;4．静态分配与对象池&quot;">​</a></h4>',14))])}const y=e(l,[["render",r]]);export{g as __pageData,y as default};
