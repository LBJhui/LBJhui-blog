import{_ as i,c as a,a0 as e,o as t}from"./chunks/framework.V6wbqQ68.js";const o=JSON.parse('{"title":"第 15 章 DOM 扩展","description":"","frontmatter":{},"headers":[],"relativePath":"website/language/JavaScript/High-Performance JavaScript/第15章 DOM扩展.md","filePath":"website/language/JavaScript/High-Performance JavaScript/第15章 DOM扩展.md"}'),n={name:"website/language/JavaScript/High-Performance JavaScript/第15章 DOM扩展.md"};function l(h,s,p,k,d,r){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="第-15-章-dom-扩展" tabindex="-1">第 15 章 DOM 扩展 <a class="header-anchor" href="#第-15-章-dom-扩展" aria-label="Permalink to &quot;第 15 章 DOM 扩展&quot;">​</a></h1><h2 id="_15-1-selectors-api" tabindex="-1">15.1 Selectors API <a class="header-anchor" href="#_15-1-selectors-api" aria-label="Permalink to &quot;15.1 Selectors API&quot;">​</a></h2><p>Selectors API Level 1 的核心是两个方法：<code>querySelector()</code>和 <code>querySelectorAll()</code>。在兼容浏览器中，Document 类型和 Element 类型的实例上都会暴露这两个方法。</p><p>Selectors API Level 2 规范在 Element 类型上新增了更多方法，比如 <code>matches()</code>、<code>find()</code>和 <code>findAll()</code>。不过，目前还没有浏览器实现或宣称实现 <code>find()</code>和 <code>findAll()</code>。</p><h3 id="_15-1-1-queryselector" tabindex="-1">15.1.1 querySelector() <a class="header-anchor" href="#_15-1-1-queryselector" aria-label="Permalink to &quot;15.1.1 querySelector()&quot;">​</a></h3><p><code>querySelector()</code>方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回 <code>null</code>。</p><p>在 <code>Document</code> 上使用 <code>querySelector()</code>方法时，会从文档元素开始搜索；在 <code>Element</code> 上使用 <code>querySelector()</code>方法时，则只会从当前元素的后代中查询。</p><h3 id="_15-1-2-queryselectorall" tabindex="-1">15.1.2 querySelectorAll() <a class="header-anchor" href="#_15-1-2-queryselectorall" aria-label="Permalink to &quot;15.1.2 querySelectorAll()&quot;">​</a></h3><p><code>querySelectorAll()</code>方法跟 <code>querySelector()</code>一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个 <code>NodeList</code> 的静态实例。如果没有匹配项，则返回空的 <code>NodeList</code> 实例。返回的 <code>NodeList</code> 对象可以通过 <code>for-of</code> 循环、<code>item()</code>方法或中括号语法取得个别元素。</p><p>如果选择符有语法错误或碰到不支持的选择符，则 <code>querySelector()</code>方法和 <code>querySelectorAll()</code>方法会抛出错误。</p><h3 id="_15-1-3-matches" tabindex="-1">15.1.3 matches() <a class="header-anchor" href="#_15-1-3-matches" aria-label="Permalink to &quot;15.1.3 matches()&quot;">​</a></h3><p><code>matches()</code>方法（在规范草案中称为 <code>matchesSelector()</code>）接收一个 CSS 选择符参数，如果元素匹配则该选择符返回 <code>true</code>，否则返回 <code>false</code>。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;birds&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Orange-winged parrot&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;endangered&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Philippine eagle&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Great white pelican&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> birds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;li&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> birds.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (birds[i].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matches</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.endangered&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;The &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> birds[i].textContent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; is endangered!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="_15-2-元素遍历" tabindex="-1">15.2 元素遍历 <a class="header-anchor" href="#_15-2-元素遍历" aria-label="Permalink to &quot;15.2 元素遍历&quot;">​</a></h2><p>Element Traversal API 为 <code>DOM</code> 元素添加了 5 个属性：</p><p>❑ childElementCount，返回子元素数量（不包含文本节点和注释）​；<br> ❑ firstElementChild，指向第一个 Element 类型的子元素（Element 版 firstChild）​；<br> ❑ lastElementChild，指向最后一个 Element 类型的子元素（Element 版 lastChild）​；<br> ❑ previousElementSibling，指向前一个 Element 类型的同胞元素（Element 版 previousSibling）​；<br> ❑ nextElementSibling，指向后一个 Element 类型的同胞元素（Element 版 nextSibling）​。</p><h2 id="_15-3-html5" tabindex="-1">15.3 HTML5 <a class="header-anchor" href="#_15-3-html5" aria-label="Permalink to &quot;15.3 HTML5&quot;">​</a></h2><h3 id="_15-3-1-css-类扩展" tabindex="-1">15.3.1 CSS 类扩展 <a class="header-anchor" href="#_15-3-1-css-类扩展" aria-label="Permalink to &quot;15.3.1 CSS 类扩展&quot;">​</a></h3><h4 id="_1-getelementsbyclassname" tabindex="-1">1．getElementsByClassName() <a class="header-anchor" href="#_1-getelementsbyclassname" aria-label="Permalink to &quot;1．getElementsByClassName()&quot;">​</a></h4><h4 id="_2-classlist-属性" tabindex="-1">2．classList 属性 <a class="header-anchor" href="#_2-classlist-属性" aria-label="Permalink to &quot;2．classList 属性&quot;">​</a></h4><p><code>classList</code> 是一个新的集合类型 <code>DOMTokenList</code> 的实例。与其他 <code>DOM</code> 集合类型一样，<code>DOMTokenList</code> 也有 <code>length</code> 属性表示自己包含多少项，也可以通过 <code>item()</code>或中括号取得个别的元素。此外，<code>DOMTokenList</code> 还增加了以下方法。</p><p>❑ add（value）​，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。<br> ❑ contains（value）​，返回布尔值，表示给定的 value 是否存在。<br> ❑ remove（value）​，从类名列表中删除指定的字符串值 value。<br> ❑ toggle（value）​，如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。</p><h3 id="_15-3-2-焦点管理" tabindex="-1">15.3.2 焦点管理 <a class="header-anchor" href="#_15-3-2-焦点管理" aria-label="Permalink to &quot;15.3.2 焦点管理&quot;">​</a></h3><p>HTML5 增加了辅助 DOM 焦点管理的功能。首先是 <code>document.activeElement</code>，始终包含当前拥有焦点的 DOM 元素。其次是 <code>document.hasFocus()</code>方法，该方法返回布尔值，表示文档是否拥有焦点。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> button </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myButton&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">button.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.activeElement </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> button) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasFocus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><h3 id="_15-3-3-htmldocument-扩展" tabindex="-1">15.3.3 HTMLDocument 扩展 <a class="header-anchor" href="#_15-3-3-htmldocument-扩展" aria-label="Permalink to &quot;15.3.3 HTMLDocument 扩展&quot;">​</a></h3><h4 id="_1-readystate-属性" tabindex="-1">1．readyState 属性 <a class="header-anchor" href="#_1-readystate-属性" aria-label="Permalink to &quot;1．readyState 属性&quot;">​</a></h4><p><code>document.readyState</code> 属性有两个可能的值：</p><p>❑ loading，表示文档正在加载；<br> ❑ complete，表示文档加载完成。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (document.readyState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;complete&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 执行操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_2-compatmode-属性" tabindex="-1">2．compatMode 属性 <a class="header-anchor" href="#_2-compatmode-属性" aria-label="Permalink to &quot;2．compatMode 属性&quot;">​</a></h4><p>自从 IE6 提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。IE 为 <code>document</code> 添加了 <code>compatMode</code> 属性，这个属性唯一的任务是指示浏览器当前处于什么渲染模式。如下面的例子所示，标准模式下 <code>document.compatMode</code> 的值是&quot;CSS1Compat&quot;，而在混杂模式下，<code>document.compatMode</code> 的值是&quot;BackCompat&quot;：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (document.compatMode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;CSS1Compat&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Standards mode&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Quirks mode&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_3-head-属性" tabindex="-1">3．head 属性 <a class="header-anchor" href="#_3-head-属性" aria-label="Permalink to &quot;3．head 属性&quot;">​</a></h4><p>作为对 <code>document.body</code>（指向文档的<code>&lt;body&gt;</code>元素）的补充，HTML5 增加了 <code>document.head</code> 属性，指向文档的<code>&lt;head&gt;</code>元素。<code>document.head</code></p><h3 id="_15-3-4-字符集属性" tabindex="-1">15.3.4 字符集属性 <a class="header-anchor" href="#_15-3-4-字符集属性" aria-label="Permalink to &quot;15.3.4 字符集属性&quot;">​</a></h3><p><code>characterSet</code> 属性表示文档实际使用的字符集，也可以用来指定新字符集。<code>document.characterSet = &quot;UTF-8&quot;;</code></p><h3 id="_15-3-5-自定义数据属性" tabindex="-1">15.3.5 自定义数据属性 <a class="header-anchor" href="#_15-3-5-自定义数据属性" aria-label="Permalink to &quot;15.3.5 自定义数据属性&quot;">​</a></h3><p>HTML5 允许给元素指定非标准的属性，但要使用前缀 <code>data-</code>以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，<code>data-</code>后面跟什么都可以。定义了自定义数据属性后，可以通过元素的 <code>dataset</code> 属性来访问。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDiv&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> data-appId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;12345&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> data-myname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Nicholas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 本例中使用的方法仅用于示范</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myDiv&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 取得自定义数据属性的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> appId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div.dataset.appId</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div.dataset.myname</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 设置自定义数据属性的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  div.dataset.appId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 23456</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  div.dataset.myname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Michael&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 有&quot;myname&quot;吗？</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (div.dataset.myname) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dataset</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myname</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="_15-3-6-插入标记" tabindex="-1">15.3.6 插入标记 <a class="header-anchor" href="#_15-3-6-插入标记" aria-label="Permalink to &quot;15.3.6 插入标记&quot;">​</a></h3><h4 id="_1-innerhtml-属性" tabindex="-1">1．innerHTML 属性 <a class="header-anchor" href="#_1-innerhtml-属性" aria-label="Permalink to &quot;1．innerHTML 属性&quot;">​</a></h4><p>在写入模式下，赋给 <code>innerHTML</code> 属性的值会被解析为 <code>DOM</code> 子树，并替代元素之前的所有节点。因为所赋的值默认为 <code>HTML</code>，所以其中的所有标签都会以浏览器处理 <code>HTML</code> 的方式转换为元素（转换结果也会因浏览器不同而不同）​。如果赋值中不包含任何 <code>HTML</code> 标签，则直接生成一个文本节点。设置完 <code>innerHTML</code>，马上就可以像访问其他节点一样访问这些新节点。</p><div class="tip custom-block"><p class="custom-block-title">注意</p><p>设置 <code>innerHTML</code> 会导致浏览器将 <code>HTML</code> 字符串解析为相应的 <code>DOM</code> 树。这意味着设置 <code>innerHTML</code> 属性后马上再读出来会得到不同的字符串。这是因为返回的字符串是将原始字符串对应的 <code>DOM</code> 子树序列化之后的结果。</p></div><h4 id="_2-旧-ie-中的-innerhtml" tabindex="-1">2．旧 IE 中的 innerHTML <a class="header-anchor" href="#_2-旧-ie-中的-innerhtml" aria-label="Permalink to &quot;2．旧 IE 中的 innerHTML&quot;">​</a></h4><h4 id="_3-outerhtml-属性" tabindex="-1">3．outerHTML 属性 <a class="header-anchor" href="#_3-outerhtml-属性" aria-label="Permalink to &quot;3．outerHTML 属性&quot;">​</a></h4><p>读取 <code>outerHTML</code> 属性时，会返回调用它的元素（及所有后代元素）的 <code>HTML</code> 字符串。在写入 <code>outerHTML</code> 属性时，调用它的元素会被传入的 <code>HTML</code> 字符串经解释之后生成的 <code>DOM</code> 子树取代。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.outerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&lt;p&gt;This is a paragraph.&lt;/p&gt;&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;This is a paragraph.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.parentNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, div)</span></span></code></pre></div><h4 id="_4-insertadjacenthtml-与-insertadjacenttext" tabindex="-1">4．insertAdjacentHTML()与 insertAdjacentText() <a class="header-anchor" href="#_4-insertadjacenthtml-与-insertadjacenttext" aria-label="Permalink to &quot;4．insertAdjacentHTML()与 insertAdjacentText()&quot;">​</a></h4><p>关于插入标签的最后两个新增方法是 <code>insertAdjacentHTML()</code>和 ·。这两个方法最早源自 IE，它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本。第一个参数必须是下列值中的一个：</p><p>❑ &quot;beforebegin&quot;，插入当前元素前面，作为前一个同胞节点；<br> ❑ &quot;afterbegin&quot;，插入当前元素内部，作为新的子节点或放在第一个子节点前面；<br> ❑ &quot;beforeend&quot;，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；<br> ❑ &quot;afterend&quot;，插入当前元素后面，作为下一个同胞节点。</p><p>注意这几个值是不区分大小写的。第二个参数会作为 <code>HTML</code> 字符串解析（与 <code>innerHTML</code> 和 <code>outerHTML</code> 相同）或者作为纯文本解析（与 <code>innerText</code> 和 <code>outerText</code> 相同）​。如果是 <code>HTML</code>，则会在解析出错时抛出错误。下面展示了基本用法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 作为前一个同胞节点插入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentHTML</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;beforebegin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;p&gt;Hello world! &lt;/p&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;beforebegin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello world! &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 作为第一个子节点插入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentHTML</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;afterbegin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;p&gt;Hello world! &lt;/p&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;afterbegin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello world! &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 作为最后一个子节点插入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentHTML</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;beforeend&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;p&gt;Hello world! &lt;/p&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;beforeend&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello world! &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 作为下一个同胞节点插入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentHTML</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;afterend&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;p&gt;Hello world! &lt;/p&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;afterend&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello world! &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h4 id="_5-内存与性能问题" tabindex="-1">5．内存与性能问题 <a class="header-anchor" href="#_5-内存与性能问题" aria-label="Permalink to &quot;5．内存与性能问题&quot;">​</a></h4><h4 id="_6-跨站点脚本" tabindex="-1">6．跨站点脚本 <a class="header-anchor" href="#_6-跨站点脚本" aria-label="Permalink to &quot;6．跨站点脚本&quot;">​</a></h4><h3 id="_15-3-7-scrollintoview" tabindex="-1">15.3.7 scrollIntoView() <a class="header-anchor" href="#_15-3-7-scrollintoview" aria-label="Permalink to &quot;15.3.7 scrollIntoView()&quot;">​</a></h3><p><code>scrollIntoView()</code>方法存在于所有 <code>HTML</code> 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>❑ alignToTop是一个布尔值。</span></span>
<span class="line"><span>  ■ true：窗口滚动后元素的顶部与视口顶部对齐。</span></span>
<span class="line"><span>  ■ false：窗口滚动后元素的底部与视口底部对齐。</span></span>
<span class="line"><span>❑ scrollIntoViewOptions是一个选项对象。</span></span>
<span class="line"><span>  ■ behavior：定义过渡动画，可取的值为&quot;smooth&quot;和&quot;auto&quot;，默认为&quot;auto&quot;。</span></span>
<span class="line"><span>  ■ block：定义垂直方向的对齐，可取的值为&quot;start&quot;、&quot;center&quot;、&quot;end&quot;和&quot;nearest&quot;，默认为&quot;start&quot;。</span></span>
<span class="line"><span>  ■ inline：定义水平方向的对齐，可取的值为&quot;start&quot;、&quot;center&quot;、&quot;end&quot;和&quot;nearest&quot;，默认为&quot;nearest&quot;。</span></span>
<span class="line"><span>❑ 不传参数等同于alignToTop为true。</span></span></code></pre></div><h2 id="_15-4-专有扩展" tabindex="-1">15.4 专有扩展 <a class="header-anchor" href="#_15-4-专有扩展" aria-label="Permalink to &quot;15.4 专有扩展&quot;">​</a></h2><h3 id="_15-4-1-children-属性" tabindex="-1">15.4.1 children 属性 <a class="header-anchor" href="#_15-4-1-children-属性" aria-label="Permalink to &quot;15.4.1 children 属性&quot;">​</a></h3><p><code>children</code> 属性是一个 <code>HTMLCollection</code>，只包含元素的 <code>Element</code> 类型的子节点。如果元素的子节点类型全部是元素类型，那 <code>children</code> 和 <code>childNodes</code> 中包含的节点应该是一样的。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> childCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.children.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.children[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><h3 id="_15-4-2-contains-方法" tabindex="-1">15.4.2 contains()方法 <a class="header-anchor" href="#_15-4-2-contains-方法" aria-label="Permalink to &quot;15.4.2 contains()方法&quot;">​</a></h3><p><code>contains()</code>方法用于需要确定一个元素是不是另一个元素的后代，应该在要搜索的祖先元素上调用，参数是待确定的目标节点。如果目标节点是被搜索节点的后代，<code>contains()</code>返回 <code>true</code>，否则返回 <code>false</code>。</p><p>DOM Level 3 的 <code>compareDocumentPosition()</code>方法也可以确定节点间的关系。这个方法会返回表示两个节点关系的位掩码。下表给出了这些位掩码的说明。</p><table tabindex="0"><thead><tr><th style="text-align:center;">掩码</th><th style="text-align:center;">节点关系</th></tr></thead><tbody><tr><td style="text-align:center;">0x1</td><td style="text-align:center;">断开（传入节点不在文档中）</td></tr><tr><td style="text-align:center;">0x2</td><td style="text-align:center;">领先（传入的节点在 DOM 树中位于参考节点之前）</td></tr><tr><td style="text-align:center;">0x4</td><td style="text-align:center;">随后（传入的节点在 DOM 树中位于参考节点之后）</td></tr><tr><td style="text-align:center;">0x8</td><td style="text-align:center;">包含（传入的节点是参考节点的祖先）</td></tr><tr><td style="text-align:center;">0x10</td><td style="text-align:center;">被包含（传入的节点是参考节点的后代）</td></tr></tbody></table><p>要模仿 ·方法，就需要用到掩码 16（0x10）​。<code>compareDocumentPosition()</code>方法的结果可以通过按位与来确定参考节点是否包含传入的节点，比如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.documentElement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compareDocumentPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0x10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><h3 id="_15-4-3-插入标记" tabindex="-1">15.4.3 插入标记 <a class="header-anchor" href="#_15-4-3-插入标记" aria-label="Permalink to &quot;15.4.3 插入标记&quot;">​</a></h3><h4 id="_1-innertext-属性" tabindex="-1">1．innerText 属性 <a class="header-anchor" href="#_1-innertext-属性" aria-label="Permalink to &quot;1．innerText 属性&quot;">​</a></h4><p><code>innerText</code> 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时，<code>innerText</code> 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，<code>innerText</code> 会移除元素的所有后代并插入一个包含该值的文本节点。</p><h4 id="_2-outertext-属性" tabindex="-1">2．outerText 属性 <a class="header-anchor" href="#_2-outertext-属性" aria-label="Permalink to &quot;2．outerText 属性&quot;">​</a></h4><p><code>outerText</code> 与 <code>innerText</code> 是类似的，只不过作用范围包含调用它的节点。要读取文本值时，<code>outerText</code> 与 <code>innerText</code> 实际上会返回同样的内容。但在写入文本值时，<code>outerText</code> 就大不相同了。写入文本值时，<code>outerText</code> 不止会移除所有后代节点，而是会替换整个元素。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.outerText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Hello world! &#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello world! &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.parentNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text, div)</span></span></code></pre></div><h3 id="_15-4-4-滚动" tabindex="-1">15.4.4 滚动 <a class="header-anchor" href="#_15-4-4-滚动" aria-label="Permalink to &quot;15.4.4 滚动&quot;">​</a></h3><p><code>scrollIntoViewIfNeeded()</code>作为 <code>HTMLElement</code> 类型的扩展可以在所有元素上调用。<code>scrollIntoViewIfNeeded(centerIfNeeded)</code>会在元素不可见的情况下，将其滚动到窗口或包含窗口中，使其可见；如果已经在视口中可见，则这个方法什么也不做。如果将可选的参数 <code>centerIfNeeded</code> 设置为 <code>true</code>，则浏览器会尝试将其放在视口中央。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-el&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scrollIntoViewIfNeeded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将元素置于可见区域的中心</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scrollIntoViewIfNeeded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将元素与可见区域中最近的边缘对齐</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">提示</p><p>非标准: 该特性是非标准的，请尽量不要在生产环境中使用它！</p></div>`,78)]))}const c=i(n,[["render",l]]);export{o as __pageData,c as default};
