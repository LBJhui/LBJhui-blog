# 第 6 章 集合引用类型

## 6.1 Object

与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。另一种方式是使用对象字面量（object literal）表示法。在使用对象字面量表示法定义对象时，并不会实际调用 Object 构造函数。

在对象字面量表示法中，属性名可以是字符串或数值，数值属性会自动转换为字符串。

属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，也可以通过变量访问属性。另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，也可以使用中括号语法。

```javascript
let person = {
  name: 'LBJ辉',
  age: 29,
  5: true,
}
console.log(person['name']) // "LBJ辉"
console.log(person.name) // "LBJ辉"
let propertyName = 'name'
console.log(person[propertyName]) // "LBJ辉"
person['first name'] = 'LBJ辉'
```

## 6.2 Array

### 6.2.1 创建数组

① 使用 Array 构造函数

```javascript
let arr = new Array()
let colors = new Array(3) // 创建一个包含3 个元素的数组
let names = new Array('Greg') // 创建一个只包含一个元素，即字符串"Greg"的数组
```

在使用 Array 构造函数时，也可以省略 new 操作符。

② 使用数组字面量（array literal）表示法。

```javascript
let colors = ['red', 'blue', 'green'] // 创建一个包含3 个元素的数组
let names = [] // 创建一个空数组
let values = [1, 2] // 创建一个包含2 个元素的数组
```

与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。

Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法：`from()`和 `of()`。`from()`用于将类数组结构转换为数组实例，而 `of()`用于将一组参数转换为数组实例。

`Array.from()`的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。

```javascript
// 字符串会被拆分为单字符数组
console.log(Array.from('Matt')) // ["M", "a", "t", "t"]

// 可以使用from()将集合和映射转换为一个新数组
const m = new Map().set(1, 2).set(3, 4)
const s = new Set().add(1).add(2).add(3).add(4)
console.log(Array.from(m)) // [[1, 2], [3, 4]]
console.log(Array.from(s)) // [1, 2, 3, 4]

// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1)
console.log(a1) // [1, 2, 3, 4]
console.log(a1 === a2) // false

// 可以使用任何可迭代对象
const iter = {
  *[Symbol.iterator]() {
    yield 1
    yield 2
    yield 3
    yield 4
  },
}
console.log(Array.from(iter)) // [1, 2, 3, 4]

// arguments对象可以被轻松地转换为数组
function getArgsArray() {
  return Array.from(arguments)
}
console.log(getArgsArray(1, 2, 3, 4)) // [1, 2, 3, 4]

// from()也能转换带有必要属性的自定义对象
const arrayLikeObject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4,
}
console.log(Array.from(arrayLikeObject)) // [1, 2, 3, 4]
```

`Array.from()`还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用 `Array.from().map()`那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中 this 的值。

```javascript
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, (x) => x ** 2)
const a3 = Array.from(
  a1,
  function (x) {
    return x ** this.exponent
  },
  { exponent: 3 }
)
console.log(a2) // [1, 4, 9, 16]
console.log(a3) // [1, 8, 27, 64]
```

`Array.of()`可以把一组参数转换为数组。这个方法用于替代在 ES6 之前常用的 `Array.prototype.slice.call(arguments)`，一种异常笨拙的将 arguments 对象转换为数组的写法：

```javascript
console.log(Array.of(1, 2, 3, 4)) // [1, 2, 3, 4]
console.log(Array.of(undefined)) // [undefined]
```

### 6.2.2 数组空位

使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）​。

ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined，ES6 之前的方法则会忽略这个空位，但具体的行为也会因方法而异。

```javascript
const options = [1, , , , 5]
for (const option of options) {
  console.log(option === undefined) // false true true true false
}

const a = Array.from([, , ,]) // 使用ES6 的Array.from()创建的包含3 个空位的数组
for (const val of a) {
  console.log(val === undefined) // true true true
}
console.log(Array.of(...[, , ,])) // [undefined, undefined, undefined]
for (const [index, value] of options.entries()) {
  console.log(value) // 1 undefined undefined undefined 5
}

// map()会跳过空位置
console.log(options.map(() => 6)) // [6, undefined, undefined, undefined, 6]
// join()视空位置为空字符串
console.log(options.join('-')) // "1----5"
```

### 6.2.3 数组索引

要取得或设置数组的值，需要使用中括号并提供相应值的数字索引。

在中括号中提供的索引表示要访问的值。如果索引小于数组包含的元素数，则返回存储在相应位置的元素。设置数组的值方法也是一样的，就是替换指定位置的值。如果把一个值设置给超过数组最大索引的索引，就像示例中的 colors[3]​，则数组长度会自动扩展到该索引值加 1。

数组中元素的数量保存在 length 属性中，这个属性始终返回 0 或大于 0 的值。数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除或添加元素。如果将 length 设置为大于数组元素数的值，则新添加的元素都将以 undefined 填充。

数组最多可以包含 4294967295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。

### 6.2.4 检测数组

使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。

为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。

```javascript
console.log(value instanceof Array)
console.log(Array.isArray(value))
```

### 6.2.5 迭代器方法

在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：`keys()`、`values()`和 `entries()`。`keys()`返回数组索引的迭代器，`values()`返回数组元素的迭代器，而 `entries()`返回索引/值对的迭代器：

```javascript
const a = ['foo', 'bar', 'baz', 'qux']
// 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过Array.from()直接转换为数组实例
console.log(Array.from(a.keys())) // [0, 1, 2, 3]
console.log(Array.from(a.values())) // [ 'foo', 'bar', 'baz', 'qux' ]
console.log(Array.from(a.entries())) // [ [ 0, 'foo' ], [ 1, 'bar' ], [ 2, 'baz' ], [ 3, 'qux' ] ]
```

> **补充**
>
> `entries()` 方法详解
>
> 1.**方法介绍** `Object.entries() `是 ES8（ECMAScript 2017）引入的一个方法，它用于将对象的所有可枚举属性转换成一个包含键值对的数组。每一个键值对都是一个数组，其中第一个元素是属性名，第二个元素是对应的属性值。
>
> 例如：
>
> ```javascript
> const obj = { a: 1, b: 2, c: 3 }
> console.log(Object.entries(obj)) // [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', 3 ] ]
> ```
>
> 2.**用法和返回值** > `Object.entries() `返回一个二维数组，其中每个元素是一个数组，包含对象的键和值。该方法不会遍历不可枚举的属性，也不会遍历原型链上的属性，只会遍历对象自身的可枚举属性。
>
> ```javascript
> const person = {
>   name: 'John',
>   age: 30,
>   job: 'developer',
> }
>
> const entries = Object.entries(person)
> console.log(entries) // [ [ 'name', 'John' ], [ 'age', 30 ], [ 'job', 'developer' ] ]
> ```
>
> 3.**数组遍历中的应用** > `entries()` 方法常常用于通过 for...of 循环遍历对象的键值对。这种方式使得代码更加简洁，且能够同时访问键和值：
>
> ```javascript
> for (const [key, value] of Object.entries(person)) {
>   console.log(`${key}: ${value}`)
> }
> // 'name: John'
> // 'age: 30'
> // 'job: developer'
> ```
>
> 这种写法在处理复杂的对象时非常有用，尤其是在动态处理对象属性时。
>
> 4.在数组中的应用
>
> 除了用于对象，`Object.entries()` 还可以用于数组。对于数组，它将数组的索引和对应的值作为键值对返回：
>
> ```javascript
> const arr = ['apple', 'banana', 'cherry']
> console.log(Object.entries(arr)) // [ [ '0', 'apple' ], [ '1', 'banana' ], [ '2', 'cherry' ] ]
> ```
>
> 通过这种方式，你可以在遍历数组时，轻松获取索引和值。
>
> 5.**应用场景**
>
> - **遍历对象属性**：如果你想遍历一个对象的属性并进行一些操作，Object.entries() 提供了一种简便的方式。
> - **处理动态数据**：对于动态生成的对象，使用 entries() 可以轻松地访问每个属性及其值。
> - **转换对象格式**：当需要将对象的数据转换为其他形式（如数组、映射）时，entries() 是一个非常有效的工具。

### 6.2.6 复制和填充方法

ES6 新增了两个方法：批量复制方法 `copyWithin()`，以及填充数组方法 `fill()`。

使用 `fill()`方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：

```javascript
const zeroes = [0, 0, 0, 0, 0]
// 用5 填充整个数组
zeroes.fill(5)
console.log(zeroes) // [5, 5, 5, 5, 5]

zeroes.fill(0) // 重置
// 用6 填充索引大于等于3 的元素
zeroes.fill(6, 3)
console.log(zeroes) // [0, 0, 0, 6, 6]

zeroes.fill(0) // 重置
// 用7 填充索引大于等于1 且小于3 的元素
zeroes.fill(7, 1, 3)
console.log(zeroes) // [0, 7, 7, 0, 0]

zeroes.fill(0) // 重置
// 用8 填充索引大于等于 1 且小于4 的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1)
console.log(zeroes) // [0, 8, 8, 8, 0];
```

`fill()`静默忽略超出数组边界、零长度及方向相反的索引范围：

```javascript
const zeroes = [0, 0, 0, 0, 0]
// 索引过低，忽略
zeroes.fill(1, -10, -6)
console.log(zeroes) // [0, 0, 0, 0, 0]
// 索引过高，忽略
zeroes.fill(1, 10, 15)
console.log(zeroes) // [0, 0, 0, 0, 0]
// 索引反向，忽略
zeroes.fill(2, 4, 2)
console.log(zeroes) // [0, 0, 0, 0, 0]
// 索引部分可用，填充可用部分
zeroes.fill(4, 3, 10)
console.log(zeroes) // [0, 0, 0, 4, 4]
```

与 `fill()`不同，`copyWithin()`会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 `fill()`使用同样的计算方法：

```javascript
let ints,
  reset = () => (ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
reset()
// 从ints中复制索引0 开始的内容，插入到索引5 开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5)
console.log(ints) // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]

reset()
// 从ints中复制索引5 开始的内容，插入到索引0 开始的位置
ints.copyWithin(0, 5)
console.log(ints) // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]

reset()
// 从ints中复制索引0 开始到索引3 结束的内容
// 插入到索引4 开始的位置
ints.copyWithin(4, 0, 3)
console.log(ints) // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]

reset()
// JavaScript引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6)
console.log(ints) // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]

reset()
// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的
ints.copyWithin(-4, -7, -3)
console.log(ints) // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

`copyWithin()`静默忽略超出数组边界、零长度及方向相反的索引范围：

```javascript
let ints,
  reset = () => (ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
reset()
// 索引过低，忽略
ints.copyWithin(1, -15, -12)
console.log(ints) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

reset()
// 索引过高，忽略
ints.copyWithin(1, 12, 15)
console.log(ints) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

reset()
// 索引反向，忽略
ints.copyWithin(2, 4, 2)
console.log(ints) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

reset()
// 索引部分可用，复制、填充可用部分
ints.copyWithin(4, 7, 10)
console.log(ints) // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9]
```

### 6.2.7 转换方法

`valueOf()`返回的还是数组本身。而 `toString()`返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。

```javascript
let colors = ['red', 'blue', 'green'] // 创建一个包含3 个字符串的数组
console.log(colors.toString()) // 'red,blue,green'
console.log(colors.valueOf()) // [ 'red', 'blue', 'green' ]
console.log(colors) // [ 'red', 'blue', 'green' ]
```

`toLocaleString()`方法也可能返回跟 `toString()`和 `valueOf()`相同的结果，但也不一定。在调用数组的 `toLocaleString()`方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的 `toLocaleString()`方法，而不是 `toString()`方法。

```javascript
let person1 = {
  toLocaleString() {
    return 'Nikolaos'
  },
  toString() {
    return 'Nicholas'
  },
}
let person2 = {
  toLocaleString() {
    return 'Grigorios'
  },
  toString() {
    return 'Greg'
  },
}
let people = [person1, person2]
console.log(people.toString()) // 'Nicholas,Greg'
console.log(people.toLocaleString()) // Nikolaos,Grigorios
```

`join()`方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。

### 6.2.8 栈方法

`push()`方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。

`pop()`方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。

### 6.2.9 队列方法

`shift()`会删除数组的第一项并返回它，然后数组长度减 1。

`unshift()`在数组开头添加任意多个值，然后返回新的数组长度。

### 6.2.10 排序方法

`reverse()`方法就是将数组元素反向排列。

默认情况下，`sort()`会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，`sort()`会在每一项上调用 `String()`转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。

`sort()`方法可以接收一个比较函数，用于判断哪个值应该排在前面。比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。

`reverse()`和 `sort()`都返回调用它们的数组的引用。

### 6.2.11 操作方法

`concat()`方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则 `concat()`会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。

```javascript
let colors = ['red', 'green', 'blue']
let colors2 = colors.concat('yellow', ['black', 'brown'])
let colors3 = colors.concat('yellow', ['black', ['brown']])
console.log(colors) // [ 'red', 'green', 'blue' ]
console.log(colors2) // [ 'red', 'green', 'blue', 'yellow', 'black', 'brown' ]
console.log(colors3) // [ 'red','green','blue','yellow','black',[ 'brown' ]]
```

打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：`Symbol.isConcat-Spreadable`。这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象：

```javascript
let colors = ['red', 'green', 'blue']
let newColors = ['black', 'brown']
let moreNewColors = {
  [Symbol.isConcatSpreadable]: true,
  length: 2,
  0: 'pink',
  1: 'cyan',
}
newColors[Symbol.isConcatSpreadable] = false
// 强制不打平数组
let colors2 = colors.concat('yellow', newColors)
// 强制打平类数组对象
let colors3 = colors.concat(moreNewColors)
console.log(colors) // [ 'red', 'green', 'blue' ]
console.log(colors2) // [ 'red', 'green', 'blue', 'yellow', [ 'black', 'brown', Symbol(Symbol.isConcatSpreadable): false ]]
console.log(colors3) // [ 'red', 'green', 'blue', 'pink', 'cyan' ]
```

`slice()`用于创建一个包含原有数组中一个或多个元素的新数组。`slice()`方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 `slice()`会返回该索引到数组末尾的所有元素。如果有两个参数，则 `slice()`返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。如果 `slice()`的参数有负值，那么就以数值长度加上这个负值的结果确定位置。

```javascript
let colors = ['red', 'green', 'blue', 'yellow', 'purple']
console.log(colors.slice(1)) // ['green', 'blue', 'yellow', 'purple']
console.log(colors) // ['red', 'green', 'blue', 'yellow', 'purple']
console.log(colors.slice(1, 4)) // ['green', 'blue', 'yellow']
```

`splice()`的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法。

❑ 删除。需要给 `splice()`传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。
❑ 插入。需要给 `splice()`传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。
❑ 替换。`splice()`在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。

```javascript
let colors = ['red', 'green', 'blue']
let removed = colors.splice(0, 1) // 删除第一项
console.log(colors) // [ 'green', 'blue' ]
console.log(removed) // [ 'red' ]，只有一个元素的数组
removed = colors.splice(1, 0, 'yellow', 'orange') // 在位置1 插入两个元素
console.log(colors) // [ 'green', 'yellow', 'orange', 'blue' ]
console.log(removed) // [] 空数组
removed = colors.splice(1, 1, 'red', 'purple') // 插入两个值，删除一个元素
console.log(colors) // [ 'green', 'red', 'purple', 'orange', 'blue' ]
console.log(removed) // [ 'yellow' ]，只有一个元素的数组
```

### 6.2.12 搜索和位置方法

#### 1．严格相等

ECMAScript 提供了 3 个严格相等的搜索方法：`indexOf()`、`lastIndexOf()`和 `includes()`。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。`indexOf()`和 `includes()`方法从数组前头（第一项）开始向后搜索，而 `lastIndexOf()`从数组末尾（最后一项）开始向前搜索。

`indexOf()`和 `lastIndexOf()`都返回要查找的元素在数组中的位置，如果没找到则返回-1。`includes()`返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（===）比较，也就是说两项必须严格相等。

#### 2．断言函数

ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。

断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。

`find()`和 `findIndex()`方法使用了断言函数。这两个方法都从数组的最小索引开始。`find()`返回第一个匹配的元素，`findIndex()`返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。

```javascript
const people = [
  {
    name: 'Matt',
    age: 27,
  },
  {
    name: 'Nicholas',
    age: 29,
  },
]
console.log(people.find((element, index, array) => element.age < 28)) // { name: 'Matt', age: 27 }
console.log(people.findIndex((element, index, array) => element.age < 28)) // 0
```

### 6.2.13 迭代方法

ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）​。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。数组的 5 个迭代方法如下。

❑ `every()`：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。
❑ `filter()`：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。
❑ `forEach()`：对数组每一项都运行传入的函数，没有返回值。
❑ `map()`：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
❑ `some()`：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。

### 6.2.14 归并方法

`reduce()`方法从数组第一项开始遍历到最后一项。而 `reduceRight()`从最后一项开始遍历至第一项。

两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给 `reduce()`和 `reduceRight()`的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值）​，则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。

## 6.3 定型数组
