# 第 17 章 事件

## 17.1 事件流

### 17.1.1 事件冒泡

IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）​。

事件沿 DOM 树一路向上，在经过的每个节点上依次触发，直至到达 `document` 对象。现代浏览器中的事件会一直冒泡到 `window` 对象。

### 17.1.2 事件捕获

事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。所有浏览器都是从 `window` 对象开始捕获事件，而 DOM2 Events 规范规定的是从 `document` 开始。

### 17.1.3 DOM 事件流

DOM2 Events 规范规定事件流分为 3 个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。

## 17.2 事件处理程序

为响应事件而调用的函数被称为事件处理程序（或事件监听器）​。事件处理程序的名字以"on"开头。

### 17.2.1 HTML 事件处理程序

特定元素支持的每个事件都可以使用事件处理程序的名字以 HTML 属性的形式来指定。此时属性的值必须是能够执行的 JavaScript 代码。

```html
<input type="button" value="Click Me" onclick="console.log('Clicked')" />
```

在 HTML 中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本。以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量 `event`，其中保存的就是[ `event` 对象](#event)。在这个函数中，this 值相当于事件的目标元素。

```html
<input type="button" value="Click Me" onclick="showMessage()" />
<!-- 输出"click" -->
<input type="button" value="Click Me" onclick="console.log(event.type)" />
<!-- 输出"Click Me" -->
<input type="button" value="Click Me" onclick="console.log(this.value)" />
<script>
  function showMessage() {
    console.log('Hello world! ')
  }
</script>
```

这个动态创建的包装函数还有一个特别有意思的地方，就是其作用域链被扩展了。在这个函数中，`document` 和元素自身的成员都可以被当成局部变量来访问。这是通过使用 `with` 实现的：

```javascript
function () {
  with (document) {
    with (this) {
      // 属性值
    }
  }
}
```

这意味着事件处理程序可以更方便地访问自己的属性。下面的代码与前面的示例功能一样：

```html
<!-- 输出"Click Me" -->
<input type="button" value="Click Me" onclick="console.log(value)" />
```

如果这个元素是一个表单输入框，则作用域链中还会包含表单元素，事件处理程序对应的函数等价于如下这样：

```javascript
function () {
  with (document) {
    with (this.form) {
      with (this) {
        // 属性值
      }
    }
  }
}
```

在 HTML 中指定事件处理程序有一些问题。第一个问题是时机问题。有可能 HTML 元素已经显示在页面上，用户都与其交互了，而事件处理程序的代码还无法执行。为此，大多数 HTML 事件处理程序会封装在 `try/catch` 块中，以便在这种情况下静默失败。另一个问题是对事件处理程序作用域链的扩展在不同浏览器中可能导致不同的结果。不同 JavaScript 引擎中标识符解析的规则存在差异，因此访问无限定的对象成员可能导致错误。使用 HTML 指定事件处理程序的最后一个问题是 HTML 与 JavaScript 强耦合。

### 17.2.2 DOM0 事件处理程序

事件处理程序会在元素的作用域中运行，即 `this` 等于元素。

```javascript
let btn = document.getElementById('myBtn')
btn.onclick = function () {
  console.log(this.id) // myBtn
}
btn.onclick = null // 移除事件处理程序
```

以这种方式添加事件处理程序是注册在事件流的冒泡阶段的。

:::tip 注意
如果事件处理程序是在 HTML 中指定的，则 onclick 属性的值是一个包装相应 HTML 事件处理程序属性值的函数。这些事件处理程序也可以通过在 JavaScript 中将相应属性设置为 null 来移除。
:::

### 17.2.3 DOM2 事件处理程序

DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：`addEventListener()`和 `removeEventListener()`。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值，`true` 表示在捕获阶段调用事件处理程序，`false`（默认值）表示在冒泡阶段调用事件处理程序。

与 DOM0 方式类似，这个事件处理程序同样在被附加到的元素的作用域中运行。使用 DOM2 方式的主要优势是可以为同一个事件添加多个事件处理程序。

```javascript
let btn = document.getElementById('myBtn')
btn.addEventListener(
  'click',
  () => {
    console.log(this.id)
  },
  false
)
btn.addEventListener(
  'click',
  () => {
    console.log('Helloworld!')
  },
  false
)
```

通过 `addEventListener()`添加的事件处理程序只能使用 `removeEventListener()`并传入与添加时同样的参数来移除。这意味着使用 `addEventListener()`添加的匿名函数无法移除。

### 17.2.4 IE 事件处理程序

IE 实现了与 DOM 类似的方法，即 `attachEvent()`和 `detachEvent()`。这两个方法接收两个同样的参数：事件处理程序的名字和事件处理函数。因为 IE8 及更早版本只支持事件冒泡，所以使用 `attachEvent()`添加的事件处理程序会添加到冒泡阶段。

使用 `attachEvent()`时，事件处理程序是在全局作用域中运行的，因此 `this` 等于 `window`。

```javascript
var btn = document.getElementById('myBtn')
btn.attachEvent('onclick', function () {
  console.log(this === window) // true
})
```

注意，`attachEvent()`的第一个参数是"`onclick`"，而不是 DOM 的 `addEventListener()`方法的"`click`"。

`attachEvent()`方法也可以给一个元素添加多个事件处理程序。与 DOM 方法不同，这里的事件处理程序会以添加它们的顺序反向触发。

### 17.2.5 跨浏览器事件处理程序

```javascript
var EventUtil = {
  addHandler: function (element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false)
    } else if (element.attachEvent) {
      element.attachEvent('on' + type, handler)
    } else {
      element['on' + type] = handler
    }
  },
  removeHandler: function (element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false)
    } else if (element.detachEvent) {
      element.detachEvent('on' + type, handler)
    } else {
      element['on' + type] = null
    }
  }
}
```

## 17.3 事件对象{#event}

在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 `event` 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。

### 17.3.1 DOM 事件对象

在 DOM 合规的浏览器中，`event` 对象是传给事件处理程序的唯一参数。不管以哪种方式（DOM0 或 DOM2）指定事件处理程序，都会传入这个 `event` 对象。

```javascript
let btn = document.getElementById('myBtn')
btn.onclick = function (event) {
  console.log(event.type) // 'click'
}
btn.addEventListener(
  'click',
  (event) => {
    console.log(event.type) // 'click'
  },
  false
)
```

如前所述，事件对象包含与特定事件相关的属性和方法。不同的事件生成的事件对象也会包含不同的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。

|         属性/方法          |     类型     | 读/写 |                                              说明                                               |
| :------------------------: | :----------: | :---: | :---------------------------------------------------------------------------------------------: |
|          bubbles           |    布尔值    | 只读  |                                        表示事件是否冒泡                                         |
|         cancelable         |    布尔值    | 只读  |                                 表示是否可以取消事件的默认行为                                  |
|       currentTarget        |     元素     | 只读  |                                   当前事件处理程序所在的元素                                    |
|      defaultPrevented      |    布尔值    | 只读  |                  true 表示已经调用 preventDefault() 方法（DOM3 Events 中新增）                  |
|           detail           |     整数     | 只读  |                                       事件相关的其他信息                                        |
|         eventPhase         |     整数     | 只读  |             表示调用处理程序的阶段：1 代表捕获阶段，2 代表到达目标，3 代表冒泡阶段              |
|      preventDefault()      |     函数     | 只读  |               用于取消事件的默认行为。只有 cancelable 为 true 才可以调用这个方法                |
| stopImmediatePropagation() |     函数     | 只读  |    用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序（DOM3 Events 中新增）     |
|     stopPropagation()      |     函数     | 只读  |          用于取消所有后续事件捕获或事件冒泡。只有 bubbles 为 true 时才可以调用这个方法          |
|           target           |     元素     | 只读  |                                            事件目标                                             |
|          trusted           |    布尔值    | 只读  | true 表示事件由浏览器生成的。false 表示事件是开发者通过 JavaScript 创建的（DOM3 Events 中新增） |
|            type            |    字符串    | 只读  |                                        被触发的事件类型                                         |
|            view            | AbstractView | 只读  |                       与事件相关的抽象视图。等于事件所发生的 window 对象                        |

在事件处理程序内部，`this` 对象始终等于 `currentTarget` 的值，而 `target` 只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标，则 `this`、`currentTarget` 和 `target` 的值是一样的。

`preventDefault()`方法用于阻止特定事件的默认动作。

`stopPropagation()`方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡。

:::tip 注意
event 对象只在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。
:::

### 17.3.2 IE 事件对象

与 DOM 事件对象不同，IE 事件对象可以基于事件处理程序被指定的方式以不同方式来访问。如果事件处理程序是使用 DOM0 方式指定的，则 `event` 对象只是 `window` 对象的一个属性。不过，如果事件处理程序是使用 `attachEvent()`指定的，则 `event` 对象会作为唯一的参数传给处理函数。使用 `attachEvent()`时，`event` 对象仍然是 `window` 对象的属性（像 DOM0 方式那样）​，只是出于方便也将其作为参数传入。

```javascript
var btn = document.getElementById('myBtn')
btn.onclick = function () {
  letevent = window.event
  console.log(event.type) // 'click'
}

btn.attachEvent('onclick', function (event) {
  console.log(event.type) // 'click'
})
```

所有 IE 事件对象都会包含下表所列的公共属性和方法。

|  属性/方法   |  类型  | 读/写 |                                         说明                                          |
| :----------: | :----: | :---: | :-----------------------------------------------------------------------------------: |
| cancelBubble | 布尔值 | 读/写 |    默认为 false，设置为 true 可以取消冒泡（与 DOM 的 stopPropagation() 方法相同）     |
| returnValue  | 布尔值 | 读/写 | 默认为 true，设置为 false 可以取消事件默认行为（与 DOM 的 preventDefault() 方法相同） |
|  srcElement  |  元素  | 只读  |                         事件目标（与 DOM 的 target 属性相同）                         |
|     type     | 字符串 | 只读  |                                    触发的事件类型                                     |

### 17.3.3 跨浏览器事件对象

```javascript
var EventUtil = {
  addHandler: function (element, type, handler) {
    // 为节省版面，删除了之前的代码
  },
  getEvent: function (event) {
    returnevent ? event : window.event
  },
  getTarget: function (event) {
    returnevent.target || event.srcElement
  },
  preventDefault: function (event) {
    if (event.preventDefault) {
      event.preventDefault()
    } else {
      event.returnValue = false
    }
  },
  removeHandler: function (element, type, handler) {
    // 为节省版面，删除了之前的代码
  },
  stopPropagation: function (event) {
    if (event.stopPropagation) {
      event.stopPropagation()
    } else {
      event.cancelBubble = true
    }
  }
}
```

## 17.4 事件类型

DOM3 Events 定义了如下事件类型。

❑ 用户界面事件（UIEvent）​：涉及与 BOM 交互的通用浏览器事件。<br />
❑ 焦点事件（FocusEvent）​：在元素获得和失去焦点时触发。<br />
❑ 鼠标事件（MouseEvent）​：使用鼠标在页面上执行某些操作时触发。<br />
❑ 滚轮事件（WheelEvent）​：使用鼠标滚轮（或类似设备）时触发。<br />
❑ 输入事件（InputEvent）​：向文档中输入文本时触发。<br />
❑ 键盘事件（KeyboardEvent）​：使用键盘在页面上执行某些操作时触发。<br />
❑ 合成事件（CompositionEvent）​：在使用某种 IME（Input Method Editor，输入法编辑器）输入字符时触发。

### 17.4.1 用户界面事件
