# 第 24 章 网络请求与远程资源

## 24.1 XMLHttpRequest 对象

所有现代浏览器都通过 `XMLHttpRequest` 构造函数原生支持 XHR 对象：

```javascript
let xhr = new XMLHttpRequest()
```

### 24.1.1 使用 XHR

使用 XHR 对象首先要调用 `open()`方法，这个方法接收 3 个参数：请求类型（"`get`"、"`post`"等）​、请求 URL，以及表示请求是否异步的布尔值。调用 `open()`不会实际发送请求，只是为发送请求做好准备。

```javascript
xhr.open('get', 'example.php', false)
```

:::tip 注意
只能访问同源 URL，也就是域名相同、端口相同、协议相同。如果请求的 URL 与发送请求的页面在任何方面有所不同，则会抛出安全错误。
:::

要发送定义好的请求，必须像下面这样调用 `send()`方法：

```javascript
xhr.open('get', 'example.txt', false)
xhr.send(null)
```

`send()`方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传 `null`，因为这个参数在某些浏览器中是必需的。调用 `send()`之后，请求就会发送到服务器。

因为这个请求是同步的，所以 JavaScript 代码会等待服务器响应之后再继续执行。收到响应后，`XHR` 对象的以下属性会被填充上数据。

❑ responseText：作为响应体返回的文本。<br />
❑ responseXML：如果响应的内容类型是"text/xml"或"application/xml"，那就是包含响应数据的 XML DOM 文档。<br />
❑ status：响应的 HTTP 状态。<br />
❑ statusText：响应的 HTTP 状态描述。

`XHR` 对象有一个 `readyState` 属性，表示当前处在请求/响应过程的哪个阶段。这个属性有如下可能的值。

❑ 0：未初始化（Uninitialized）​。尚未调用 open()方法。<br />
❑ 1：已打开（Open）​。已调用 open()方法，尚未调用 send()方法。<br />
❑ 2：已发送（Sent）​。已调用 send()方法，尚未收到响应。<br />
❑ 3：接收中（Receiving）​。已经收到部分响应。<br />
❑ 4：完成（Complete）​。已经收到所有响应，可以使用了。

每次 `readyState` 从一个值变成另一个值，都会触发 `readystatechange` 事件。可以借此机会检查 `readyState` 的值。一般来说，我们唯一关心的 `readyState` 值是 4，表示数据已就绪。为保证跨浏览器兼容，`onreadystatechange` 事件处理程序应该在调用 `open()`之前赋值。

```javascript
let xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
      console.log(xhr.responseText)
    } else {
      console.log('Request was unsuccessful: ' + xhr.status)
    }
  }
}
xhr.open('get', 'example.txt', true)
xhr.send(null)
```

在收到响应之前如果想取消异步请求，可以调用 `abort()`方法：

```javascript
xhr.abort()
```

调用这个方法后，XHR 对象会停止触发事件，并阻止访问这个对象上任何与响应相关的属性。中断请求后，应该取消对 XHR 对象的引用。由于内存问题，不推荐重用 XHR 对象。

### 24.1.2 HTTP 头部

每个 HTTP 请求和响应都会携带一些头部字段，这些字段可能对开发者有用。XHR 对象会通过一些方法暴露与请求和响应相关的头部字段。

默认情况下，XHR 请求会发送以下头部字段。

❑ Accept：浏览器可以处理的内容类型。<br />
❑ Accept-Charset：浏览器可以显示的字符集。<br />
❑ Accept-Encoding：浏览器可以处理的压缩编码类型。<br />
❑ Accept-Language：浏览器使用的语言。<br />
❑ Connection：浏览器与服务器的连接类型。<br />
❑ Cookie：页面中设置的 Cookie。<br />
❑ Host：发送请求的页面所在的域。<br />
❑ Referer：发送请求的页面的 URI。注意，这个字段在 HTTP 规范中就拼错了，所以考虑到兼容性也必须将错就错。​（正确的拼写应该是 Referrer。​）<br />
❑ User-Agent：浏览器的用户代理字符串。

虽然不同浏览器发送的确切头部字段可能各不相同，但这些通常都是会发送的。如果需要发送额外的请求头部，可以使用 `setRequestHeader()`方法。这个方法接收两个参数：头部字段的名称和值。为保证请求头部被发送，必须在 `open()`之后、`send()`之前调用 `setRequestHeader()`。

```javascript
let xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
      console.log(xhr.responseText)
    } else {
      console.log('Request was unsuccessful: ' + xhr.status)
    }
  }
}
xhr.open('get', 'example.php', true)
xhr.setRequestHeader('MyHeader', 'MyValue')
xhr.send(null)
```

可以使用 `getResponseHeader()`方法从 XHR 对象获取响应头部，只要传入要获取头部的名称即可。如果想取得所有响应头部，可以使用 `getAllResponseHeaders()`方法，这个方法会返回包含所有响应头部的字符串。

```javascript
let myHeader = xhr.getResponseHeader('MyHeader')
let allHeaders = xhr.getAllResponseHeaders()

/**
 * getAllResponseHeaders()方法通常返回类似如下的字符串：
 *  Date: Sun, 14 Nov 2004 18:04:03 GMT
 *  Server: Apache/1.3.29 (Unix)
 *  Vary: Accept
 *  X-Powered-By: PHP/4.3.8
 *  Connection: close
 *  Content-Type: text/html; charset=iso-8859-1
 */
```

### 24.1.3 GET 请求

最常用的请求方法是 GET 请求，用于向服务器查询某些信息。发送 GET 请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用 `encodeURIComponent()`编码，所有名/值对必须以和号（&）分隔。对 XHR 而言，查询字符串必须正确编码后添加到 URL 后面，然后再传给 `open()`方法。

```javascript
function addURLParam(url, name, value) {
  url += url.indexOf('? ') == -1 ? '? ' : '&'
  url += encodeURIComponent(name) + '=' + encodeURIComponent(value)
  return url
}
```

### 24.1.4 POST 请求

第二个最常用的请求是 POST 请求，用于向服务器发送应该保存的数据。每个 POST 请求都应该在请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据可以是任意格式。

```javascript
function submitData() {
  let xhr = new XMLHttpRequest()
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        console.log(xhr.responseText)
      } else {
        console.log('Request was unsuccessful: ' + xhr.status)
      }
    }
  }
  xhr.open('post', 'postexample.php', true)
  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
  letform = document.getElementById('user-info')
  xhr.send(serialize(form))
}
```

:::tip 注意
POST 请求相比 GET 请求要占用更多资源。从性能方面说，发送相同数量的数据，GET 请求比 POST 请求要快两倍。
:::

### 24.1.5 XMLHttpRequest Level 2

#### 1．FormData 类型

现代 Web 应用程序中经常需要对表单数据进行序列化，因此 XMLHttpRequest Level 2 新增了 `FormData` 类型。`FormData` 类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR 发送。

`append()`方法接收两个参数：键和值，相当于表单字段名称和该字段的值。可以像这样添加任意多个键/值对数据。此外，通过直接给 `FormData` 构造函数传入一个表单元素，也可以将表单中的数据作为键/值对填充进去。

```javascript
let data = new FormData()
data.append('name', 'Nicholas')

let data = new FormData(document.forms[0])
```

```javascript
let xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
      console.log(xhr.responseText)
    } else {
      console.log('Request was unsuccessful: ' + xhr.status)
    }
  }
}
xhr.open('post', 'postexample.php', true)
let form = document.getElementById('user-info')
xhr.send(new FormData(form))
```

#### 2．超时

```javascript
let xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    try {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        console.log(xhr.responseText)
      } else {
        console.log('Request was unsuccessful: ' + xhr.status)
      }
    } catch (ex) {
      // 假设由ontimeout处理
    }
  }
}
xhr.open('get', 'timeout.php', true)
xhr.timeout = 1000 //设置1秒超时
xhr.ontimeout = function () {
  console.log('Request did not return in a second.')
}
xhr.send(null)
```

这个例子演示了使用 `timeout` 设置超时。给 `timeout` 设置 1000 毫秒意味着，如果请求没有在 1 秒钟内返回则会中断。此时则会触发 `ontimeout` 事件处理程序，`readyState` 仍然会变成 4，因此也会调用 `onreadystatechange` 事件处理程序。不过，如果在超时之后访问 `status` 属性则会发生错误。为做好防护，可以把检查 `status` 属性的代码封装在 `try/catch` 语句中。

#### 3．overrideMimeType()方法

`overrideMimeType()`方法用于重写 XHR 响应的 MIME 类型。

假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是 `text/plain`。结果就会导致虽然数据是 XML，但 `responseXML` 属性值是 `null`。此时调用 `overrideMimeType()`可以保证将响应当成 XML 而不是纯文本来处理：

```javascript
let xhr = new XMLHttpRequest()
xhr.open('get', 'text.php', true)
xhr.overrideMimeType('text/xml')
xhr.send(null)
```

## 24.2 进度事件

❑ loadstart：在接收到响应的第一个字节时触发。<br />
❑ progress：在接收响应期间反复触发。<br />
❑ error：在请求出错时触发。<br />
❑ abort：在调用 abort()终止连接时触发。<br />
❑ load：在成功接收完响应时触发。<br />
❑ loadend：在通信完成时，且在 error、abort 或 load 之后触发。

### 24.2.1 load 事件

Firefox 最初在实现 XHR 的时候，曾致力于简化交互模式。最终，增加了一个 load 事件用于替代 `readystatechange` 事件。`load` 事件在响应接收完成后立即触发，这样就不用检查 `readyState` 属性了。`onload` 事件处理程序会收到一个 `event` 对象，其 `target` 属性设置为 XHR 实例，在这个实例上可以访问所有 XHR 对象属性和方法。不过，并不是所有浏览器都实现了这个事件的 `event` 对象。考虑到跨浏览器兼容，还是需要像下面这样使用 XHR 对象变量：

```javascript
let xhr = new XMLHttpRequest()
xhr.onload = function () {
  if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
    console.log(xhr.responseText)
  } else {
    console.log('Requestwasunsuccessful: ' + xhr.status)
  }
}
xhr.open('get', 'altevents.php', true)
xhr.send(null)
```

只要是从服务器收到响应，无论状态码是什么，都会触发 `load` 事件。这意味着还需要检查 `status` 属性才能确定数据是否有效。Firefox、Opera、Chrome 和 Safari 都支持 load 事件。

### 24.2.2 progress 事件

Mozilla 在 XHR 对象上另一个创新是 `progress` 事件，在浏览器接收数据期间，这个事件会反复触发。每次触发时，`onprogress` 事件处理程序都会收到 `event` 对象，其 `target` 属性是 `XHR` 对象，且包含 3 个额外属性：`lengthComputable`、`position` 和 `totalSize`。其中，`lengthComputable` 是一个布尔值，表示进度信息是否可用；`position` 是接收到的字节数；`totalSize` 是响应的 Content-Length 头部定义的总字节数。有了这些信息，就可以给用户提供进度条了。

```javascript
let xhr = new XMLHttpRequest()
xhr.onload = function (event) {
  if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
    console.log(xhr.responseText)
  } else {
    console.log('Request was unsuccessful: ' + xhr.status)
  }
}
xhr.onprogress = function (event) {
  let divStatus = document.getElementById('status')
  if (event.lengthComputable) {
    divStatus.innerHTML = 'Received ' + event.position + ' of ' + event.totalSize + ' bytes'
  }
}
xhr.open('get', 'altevents.php', true)
xhr.send(null)
```

## 24.3 跨源资源共享

跨源资源共享（CORS, Cross-Origin Resource Sharing）定义了浏览器与服务器如何实现跨源通信。CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。

对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 text/plain 类型，这样的请求在发送时会有一个额外的头部叫 Origin。Origin 头部包含发送请求的页面的源（协议、域名和端口）​，以便服务器确定是否为其提供响应。

如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；或者如果资源是公开的，那么就包含"＊"。

```javascript
let xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
      console.log(xhr.responseText)
    } else {
      console.log('Request was unsuccessful: ' + xhr.status)
    }
  }
}
xhr.open('get', 'http://www.somewhere-else.com/page/', true)
xhr.send(null)
```

跨域 XHR 对象允许访问 `status` 和 `statusText` 属性，也允许同步请求。出于安全考虑，跨域 XHR 对象也施加了一些额外限制。

❑ 不能使用 setRequestHeader()设置自定义头部。<br />
❑ 不能发送和接收 cookie。<br />
❑ getAllResponseHeaders()方法始终返回空字符串。

### 24.3.1 预检请求

CORS 通过一种叫预检请求（preflighted request）的服务器验证机制，允许使用自定义头部、除 GET 和 POST 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。这个请求使用 OPTIONS 方法发送并包含以下头部。

❑ Origin：与简单请求相同。<br />
❑ Access-Control-Request-Method：请求希望使用的方法。<br />
❑ Access-Control-Request-Headers:（可选）要使用的逗号分隔的自定义头部列表。

```http
Origin: http://www.nczonline.net
Access-Control-Request-Method: POST
Access-Control-Request-Headers: NCZ
```

在这个请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送如下头部与浏览器沟通这些信息。

❑ Access-Control-Allow-Origin：与简单请求相同。<br />
❑ Access-Control-Allow-Methods：允许的方法（逗号分隔的列表）​。<br />
❑ Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）​。<br />
❑ Access-Control-Max-Age：缓存预检请求的秒数。

预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的请求时才会多发送一次额外的 HTTP 请求。

### 24.3.2 凭据请求

默认情况下，跨源请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书）​。可以通过将 withCredentials 属性设置为 true 来表明请求会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下 HTTP 头部：

```http
Access-Control-Allow-Credentials: true
```

如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给 JavaScript（`responseText` 是空字符串，`status` 是 0, `onerror()`被调用）​。注意，服务器也可以在预检请求的响应中发送这个 HTTP 头部，以表明这个源允许发送凭据请求。

## 24.4 替代性跨源技术

### 24.4.1 图片探测

任何页面都可以跨域加载图片而不必担心限制，因此这也是在线广告跟踪的主要方式。可以动态创建图片，然后通过它们的 `onload` 和 `onerror` 事件处理程序得知何时收到响应。

```javascript
let img = new Image()
img.onload = img.onerror = function () {
  console.log('Done! ')
}
img.src = 'http://www.example.com/test?name=Nicholas'
```

### 24.4.2 JSONP

JSONP 是“JSON with padding”的简写，是在 Web 服务上流行的一种 JSON 变体。

JSONP 格式包含两个部分：回调和数据。回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的。而数据就是作为参数传给回调函数的 JSON 数据。

```http
callback({ "name": "Nicholas" })
http://freegeoip.net/json/?callback=handleResponse
```

JSONP 调用是通过动态创建`<script>`元素并为 `src` 属性指定跨域 URL 实现的。此时的`<script>`与`<img>`元素类似，能够不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript，所以 JSONP 响应在被加载完成之后会立即执行。

```javascript
function handleResponse(response) {
  console.log(`
          You're at IP address ${response.ip}, which is in
          ${response.city}, ${response.region_name}`)
}
let script = document.createElement('script')
script.src = 'http://freegeoip.net/json/? callback=handleResponse'
document.body.insertBefore(script, document.body.firstChild)
```

JSONP 也有一些缺点。

首先，JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。此时除了完全删除 JSONP 没有其他办法。在使用不受控的 Web 服务时，一定要保证是可以信任的。

第二个缺点是不好确定 JSONP 请求是否失败。虽然 HTML5 规定了`<script>`元素的 `onerror` 事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应。这种方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的。

## 24.5 Fetch API

### 24.5.1 基本用法

#### 1．分派请求

`fetch()`只有一个必需的参数 `input`。多数情况下，这个参数是要获取资源的 URL。这个方法返回一个期约。

```javascript
let r = fetch('/bar')
console.log(r) // Promise <pending>

fetch('bar.txt').then((response) => {
  console.log(response)
})
// Response { type: "basic", url: ... }
```

请求完成、资源可用时，期约会解决为一个 `Response` 对象。这个对象是 API 的封装，可以通过它取得相应资源。获取资源要使用这个对象的属性和方法，掌握响应的情况并将负载转换为有用的形式。

#### 2．读取响应

读取响应内容的最简单方式是取得纯文本格式的内容，这要用到 `text()`方法。

```javascript
fetch('bar.txt').then((response) => {
  response.text().then((data) => {
    console.log(data)
  })
})

fetch('bar.txt')
  .then((response) => response.text())
  .then((data) => console.log(data))
// bar.txt的内容
```

#### 3．处理状态码和请求失败

Fetch API 支持通过 `Response` 的 `status`（状态码）和 `statusText`（状态文本）属性检查响应状态。成功获取响应的请求通常会产生值为 200 的状态码，请求不存在的资源通常会产生值为 404 的状态码，请求的 URL 如果抛出服务器错误会产生值为 500 的状态码。

```javascript
fetch('/bar').then((response) => {
  console.log(response.status) // 200
  console.log(response.statusText) // OK
})

fetch('/does-not-exist').then((response) => {
  console.log(response.status) // 404
  console.log(response.statusText) // NotFound
})

fetch('/throw-server-error').then((response) => {
  console.log(response.status) // 500
  console.log(response.statusText) // InternalServerError
})
```

可以显式地设置 `fetch()`在遇到重定向时的行为（本章后面会介绍）​，不过默认行为是跟随重定向并返回状态码不是 300~399 的响应。跟随重定向时，响应对象的 `redirected` 属性会被设置为 `true`，而状态码仍然是 200。

```javascript
fetch('/permanent-redirect').then((response) => {
  // 默认行为是跟随重定向直到最终URL
  // 这个例子会出现至少两轮网络请求
  // <origin url>/permanent-redirect -> <redirect url>
  console.log(response.status) // 200
  console.log(response.statusText) // OK
  console.log(response.redirected) // true
})
```

通常状态码为 200 时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在状态码非 200~299 时检查 `Response` 对象的 `ok` 属性。

```javascript
fetch('/bar').then((response) => {
  console.log(response.status) //200
  console.log(response.ok) //true
})
fetch('/does-not-exist').then((response) => {
  console.log(response.status) //404
  console.log(response.ok) //false
})
```

可以通过 `url` 属性检查通过 `fetch()`发送请求时使用的完整 URL。

```javascript
// foo.com/bar/baz发送的请求
console.log(window.location.href) // https://foo.com/bar/baz
fetch('qux').then((response) => console.log(response.url))
// https://foo.com/bar/qux
fetch('/qux').then((response) => console.log(response.url))
// https://foo.com/qux
fetch('//qux.com').then((response) => console.log(response.url))
// https://qux.com
fetch('https://qux.com').then((response) => console.log(response.url))
// https://qux.com
```

#### 4．自定义选项

只使用 URL 时，`fetch()`会发送 GET 请求，只包含最低限度的请求头。要进一步配置如何发送请求，需要传入可选的第二个参数 init 对象。init 对象要按照下表中的键/值进行填充。

|       键       | 值                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| :------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|      body      | 指定使用请求体时请求体的内容<br />必须是 Blob、BufferSource、FormData、URLSearchParams、ReadableStream 或 String 的实例                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|     cache      | 用于控制浏览器与 HTTP 缓存的交互。要跟踪缓存的重定向，请求的 redirect 属性值必须是 "follow"，而且必须符合同源策略限制。必须是下列值之一<br />Default<br />❑ fetch() 返回命中的有效缓存。不发送请求<br />❑ 命中无效（stale）缓存会发送条件式请求。如果相应已经改变，则更新缓存的值。然后 fetch() 返回缓存的值<br />❑ 未命中缓存会发送请求，并缓存响应。然后 fetch() 返回响应<br />no-store<br />❑ 浏览器不检查缓存，直接发送请求<br />❑ 不缓存响应，直接通过 fetch() 返回<br />reload<br />❑ 浏览器不检查缓存，直接发送请求<br />❑ 缓存响应，再通过 fetch() 返回<br />no-cache<br />❑ 无论命中有效缓存还是无效缓存都会发送条件式请求。如果响应已经改变，则更新缓存的值。然后 fetch() 返回缓存的值<br />❑ 未命中缓存会发送请求，并缓存响应。然后 fetch() 返回响应<br />force-cahce<br />❑ 无论命中有效缓存还是无效缓存都通过 fetch() 返回。不发送请求<br />❑ 未命中缓存会发送请求，并缓存响应。然后 fetch() 返回响应<br />only-if-cache<br />❑ 只在请求模式为 same-origin 时使用缓存<br />❑ 无论命中有效缓存还是无效缓存都通过 fetch() 返回。不发送请求<br />❑ 未命中缓存返回状态码为 504（网关超时）的响应<br />默认为 default |
|  credentials   | 用于指定在外发送请求中如何包含 cookie。与 XMLHttpRequest 的 widthCredentials 标签类似必须是下列字符串值之一<br />❑ omit：不发送 cookie<br />❑ same-origin：只在请求 URL 与发送 fetch() 请求的页面同源时发送 cookie<br />❑ include：无论同源还是跨源都包含 cookie<br />在支持 Credential Management API 的浏览器中，也可以是一个 FederatedCredential 或 PasswordCredential 的实例<br />默认为 same-origin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|    headers     | 用于指定请求头部<br />必须是 Header 对象实例或包含字符串格式键/值对的常规对象<br />默认值为不包含键/值对的 Headers 对象。这不意味着请求不包含任何头部，浏览器仍然会随请求发送一些头部。虽然这些头部对 JavaScript 不可见，但浏览器的网络检查器可以观察到                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|   integrity    | 用于强制资源完整性<br />必须是包含子资源完整性标识符的字符串<br />默认为空字符串                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|   keepalive    | 用于指示浏览器允许请求存在时间超出页面生命周期。适合报告事件或分析，比如页面在 fetch() 请求后很快卸载。设置 keepalive 标志的 fetch() 请求可用于替代 Navigator.sendBeacon()<br />必须是布尔值<br />默认为 false                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|     method     | 用于指定 HTTP 请求方法<br />基本上就是如下字符串值：<br />❑ GET<br />❑ POST<br />❑ PUT<br />❑ PATCH<br />❑ DELETE<br />❑ HEAD<br />❑ OPTIONS<br />❑ CONNECT<br />❑ TRACE<br />默认为 GET                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|      mode      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|    redirect    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|    referrer    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| referrerPolicy | strict-origin<br />❑ 对于从安全 HTTPS 上下文发送到 HTTP URL 的请求，不包含 Referer 头部<br />❑ 对于所有其他请求，将 Referer 设置为只包含源<br />origin-when-cross-origin<br />❑ 对于跨源请求，将 Referer 设置为只包含源<br />❑ 对于同源请求，将 Referer 设置为完整 URL<br />strict-origin-when-cross-origin<br />❑ 对于从安全 HTTPS 上下文发送到 HTTP URL 的请求，不包含 Referer 头部<br />❑ 对于所有其他跨源请求，将 Referer 设置为只包含源<br />❑ 对于同源请求，将 Referer 设置为完整 URL<br />unsafe-url<br />❑ 对于所有请求，将 Referer 设置为完整 URL<br />默认为 no-referrer-when-downgrade                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|     signal     | 用于支持通过 AbortController 中断进行中的 fetch() 请求<br />必须是 AbortSignal 的实例<br />默认为未关联控制器的 AbortSignal 实例                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

❑
