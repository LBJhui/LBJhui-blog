# 第 25 章 客户端存储

## 25.1 cookie

HTTP cookie 通常也叫作 cookie，最初用于在客户端存储会话信息。这个规范要求服务器在响应 HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息。

```http
HTTP/1.1200 OK
Content-type: text/html
Set-Cookie: name=value
Other-header: other-header-value
```

这个 HTTP 响应会设置一个名为"name"，值为"value"的 cookie。名和值在发送时都会经过 URL 编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服务器，比如：

```http
GET /index.jsl HTTP/1.1
Cookie: name=value
Other-header: other-header-value
```

这些发送回服务器的额外信息可用于唯一标识发送请求的客户端。

### 25.1.1 限制

cookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域。这个限制能保证 cookie 中存储的信息只对被认可的接收者开放，不被其他域访问。

因为 cookie 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，cookie 也不会占用太多磁盘空间。

通常，只要遵守以下大致的限制，就不会在任何浏览器中碰到问题：

❑ 不超过 300 个 cookie；<br />
❑ 每个 cookie 不超过 4096 字节；<br />
❑ 每个域不超过 20 个 cookie；<br />
❑ 每个域不超过 81920 字节。

每个域能设置的 cookie 总数也是受限的，但不同浏览器的限制不同。例如：

❑ 最新版 IE 和 Edge 限制每个域不超过 50 个 cookie；<br />
❑ 最新版 Firefox 限制每个域不超过 150 个 cookie；<br />
❑ 最新版 Opera 限制每个域不超过 180 个 cookie；<br />
❑ Safari 和 Chrome 对每个域的 cookie 数没有硬性限制。

如果 cookie 总数超过了单个域的上限，浏览器就会删除之前设置的 cookie。IE 和 Opera 会按照最近最少使用（LRU, Least Recently Used）原则删除之前的 cookie，以便为新设置的 cookie 腾出空间。Firefox 好像会随机删除之前的 cookie，因此为避免不确定的结果，最好不要超出限制。

浏览器也会限制 cookie 的大小。大多数浏览器对 cookie 的限制是不超过 4096 字节，上下可以有一个字节的误差。为跨浏览器兼容，最好保证 cookie 的大小不超过 4095 字节。这个大小限制适用于一个域的所有 cookie，而不是单个 cookie。

如果创建的 cookie 超过最大限制，则该 cookie 会被静默删除。注意，一个字符通常会占 1 字节。如果使用多字节字符（如 UTF-8 Unicode 字符）​，则每个字符最多可能占 4 字节。

### 25.1.2 cookie 的构成

cookie 在浏览器中是由以下参数构成的。

❑ 名称：唯一标识 cookie 的名称。cookie 名不区分大小写，因此 myCookie 和 MyCookie 是同一个名称。不过，实践中最好将 cookie 名当成区分大小写来对待，因为一些服务器软件可能这样对待它们。cookie 名必须经过 URL 编码。<br />
❑ 值：存储在 cookie 里的字符串值。这个值必须经过 URL 编码。<br />
❑ 域：cookie 有效的域。发送到这个域的所有请求都会包含对应的 cookie。这个值可能包含子域（如www.wrox.com）​，也可以不包含（如．wrox.com表示对wrox.com的所有子域都有效）​。如果不明确设置，则默认为设置cookie的域。<br />
❑ 路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器。例如，可以指定 cookie 只能由 http://www.wrox.com/books/ 访问，因此访问 http://www.wrox.com/ 下的页面就不会发送 cookie，即使请求的是同一个域。<br />
❑ 过期时间：表示何时删除 cookie 的时间戳（即什么时间之后就不发送到服务器了）​。默认情况下，浏览器会话结束后会删除所有 cookie。不过，也可以设置删除 cookie 的时间。这个值是 GMT 格式（Wdy, DD-Mon-YYYY HH: MM: SS GMT）​，用于指定删除 cookie 的具体时间。这样即使关闭浏览器 cookie 也会保留在用户机器上。把过期时间设置为过去的时间会立即删除 cookie。<br />
❑ 安全标志：设置之后，只在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器。例如，请求 https://www.wrox.com 会发送 cookie，而请求 http://www.wrox.com 则不会。

这些参数在 Set-Cookie 头部中使用分号加空格隔开，安全标志 secure 是 cookie 中唯一的非名/值对，只需一个 secure 就可以了。

```http
HTTP/1.1200 OK
Content-type: text/html
Set-Cookie: name=value;domain=.wrox.com;path=/;secure
Other-header: other-header-value
```

要知道，域、路径、过期时间和 secure 标志用于告诉浏览器什么情况下应该在请求中包含 cookie。这些参数并不会随请求发送给服务器，实际发送的只有 cookie 的名/值对。

### 25.1.3 JavaScript 中的 cookie

在 JavaScript 中处理 `cookie` 比较麻烦，因为接口过于简单，只有 `BOM` 的 `document.cookie` 属性。根据用法不同，该属性的表现迥异。要使用该属性获取值时，`document.cookie` 返回包含页面中所有有效 `cookie` 的字符串（根据域、路径、过期时间和安全设置）​，以分号分隔。所有名和值都是 URL 编码的，因此必须使用 `decodeURIComponent()`解码。

在设置值时，可以通过 `document.cookie` 属性设置新的 `cookie` 字符串。这个字符串在被解析后会添加到原有 `cookie` 中。设置 `document.cookie` 不会覆盖之前存在的任何 `cookie`，除非设置了已有的 `cookie`。在所有这些参数中，只有 `cookie` 的名称和值是必需的。

```http
name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure
```

```javascript
class CookieUtil {
  static get(name) {
    let cookieName = `${encodeURIComponent(name)}=`,
      cookieStart = document.cookie.indexOf(cookieName),
      cookieValue = null
    if (cookieStart > -1) {
      let cookieEnd = document.cookie.indexOf('; ', cookieStart)
      if (cookieEnd == -1) {
        cookieEnd = document.cookie.length
      }
      cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))
    }
    return cookieValue
  }
  static set(name, value, expires, path, domain, secure) {
    let cookieText = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`
    if (expires instanceof Date) {
      cookieText += `; expires=${expires.toGMTString()}`
    }
    if (path) {
      cookieText += `; path=${path}`
    }
    if (domain) {
      cookieText += `; domain=${domain}`
    }
    if (secure) {
      cookieText += '; secure'
    }
    document.cookie = cookieText
  }
  static unset(name, path, domain, secure) {
    CookieUtil.set(name, '', new Date(0), path, domain, secure)
  }
}

// 设置cookie
CookieUtil.set('name', 'Nicholas')
CookieUtil.set('book', 'Professional JavaScript')
// 读取cookie
alert(CookieUtil.get('name')) // "Nicholas"
alert(CookieUtil.get('book')) // "Professional JavaScript"
// 删除cookie
CookieUtil.unset('name')
CookieUtil.unset('book')
// 设置有路径、域和过期时间的cookie
CookieUtil.set('name', 'Nicholas', '/books/projs/', 'www.wrox.com', new Date('January 1, 2010'))
// 删除刚刚设置的cookie
CookieUtil.unset('name', '/books/projs/', 'www.wrox.com')
// 设置安全cookie
CookieUtil.set('name', 'Nicholas', null, null, null, true)
```

### 25.1.4 子 cookie

为绕过浏览器对每个域 cookie 数的限制，有些开发者提出了子 cookie 的概念。子 cookie 是在单个 cookie 存储的小块数据，本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对。

```http
name=name1=value1&name2=value2&name3=value3&name4=value4&name5=value5
```

```javascript
class SubCookieUtil {
  static get(name, subName) {
    let subCookies = SubCookieUtil.getAll(name)
    return subCookies ? subCookies[subName] : null
  }
  static getAll(name) {
    let cookieName = encodeURIComponent(name) + '=',
      cookieStart = document.cookie.indexOf(cookieName),
      cookieValue = null,
      cookieEnd,
      subCookies,
      parts,
      result = {}
    if (cookieStart > -1) {
      cookieEnd = document.cookie.indexOf('; ', cookieStart)
      if (cookieEnd == -1) {
        cookieEnd = document.cookie.length
      }
      cookieValue = document.cookie.substring(cookieStart + cookieName.length, cookieEnd)
      if (cookieValue.length > 0) {
        subCookies = cookieValue.split('&')
        for (let i = 0, len = subCookies.length; i < len; i++) {
          parts = subCookies[i].split('=')
          result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1])
        }
        return result
      }
    }
    return null
  }
  // 省略其他代码
}
```
